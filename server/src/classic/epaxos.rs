// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `epaxos.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct Command {
    // message fields
    pub op: Operation,
    pub key: ::std::string::String,
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Command {
    fn default() -> &'a Command {
        <Command as ::protobuf::Message>::default_instance()
    }
}

impl Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    // .epaxos.Operation op = 1;


    pub fn get_op(&self) -> Operation {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = Operation::PUT;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: Operation) {
        self.op = v;
    }

    // string key = 2;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for Command {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op != Operation::PUT {
            my_size += ::protobuf::rt::enum_size(1, self.op);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.op != Operation::PUT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.op))?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if self.value != 0 {
            os.write_int32(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Command {
        Command::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Operation>>(
                "op",
                |m: &Command| { &m.op },
                |m: &mut Command| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Command| { &m.key },
                |m: &mut Command| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &Command| { &m.value },
                |m: &mut Command| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Command>(
                "Command",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Command {
        static instance: ::protobuf::rt::LazyV2<Command> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Command::new)
    }
}

impl ::protobuf::Clear for Command {
    fn clear(&mut self) {
        self.op = Operation::PUT;
        self.key.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Command {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposePayload {
    // message fields
    pub command_id: u32,
    pub command: ::protobuf::SingularPtrField<Command>,
    pub timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposePayload {
    fn default() -> &'a ProposePayload {
        <ProposePayload as ::protobuf::Message>::default_instance()
    }
}

impl ProposePayload {
    pub fn new() -> ProposePayload {
        ::std::default::Default::default()
    }

    // uint32 command_id = 1;


    pub fn get_command_id(&self) -> u32 {
        self.command_id
    }
    pub fn clear_command_id(&mut self) {
        self.command_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_command_id(&mut self, v: u32) {
        self.command_id = v;
    }

    // .epaxos.Command command = 2;


    pub fn get_command(&self) -> &Command {
        self.command.as_ref().unwrap_or_else(|| <Command as ::protobuf::Message>::default_instance())
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: Command) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut Command {
        if self.command.is_none() {
            self.command.set_default();
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> Command {
        self.command.take().unwrap_or_else(|| Command::new())
    }

    // uint64 timestamp = 3;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for ProposePayload {
    fn is_initialized(&self) -> bool {
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.command_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.command_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.command_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.command.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.command_id != 0 {
            os.write_uint32(1, self.command_id)?;
        }
        if let Some(ref v) = self.command.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposePayload {
        ProposePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "command_id",
                |m: &ProposePayload| { &m.command_id },
                |m: &mut ProposePayload| { &mut m.command_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &ProposePayload| { &m.command },
                |m: &mut ProposePayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ProposePayload| { &m.timestamp },
                |m: &mut ProposePayload| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposePayload>(
                "ProposePayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposePayload {
        static instance: ::protobuf::rt::LazyV2<ProposePayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposePayload::new)
    }
}

impl ::protobuf::Clear for ProposePayload {
    fn clear(&mut self) {
        self.command_id = 0;
        self.command.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProposeReplyPayload {
    // message fields
    pub ok: bool,
    pub command_id: u32,
    pub value: i32,
    pub timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposeReplyPayload {
    fn default() -> &'a ProposeReplyPayload {
        <ProposeReplyPayload as ::protobuf::Message>::default_instance()
    }
}

impl ProposeReplyPayload {
    pub fn new() -> ProposeReplyPayload {
        ::std::default::Default::default()
    }

    // bool ok = 1;


    pub fn get_ok(&self) -> bool {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = false;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: bool) {
        self.ok = v;
    }

    // uint32 command_id = 2;


    pub fn get_command_id(&self) -> u32 {
        self.command_id
    }
    pub fn clear_command_id(&mut self) {
        self.command_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_command_id(&mut self, v: u32) {
        self.command_id = v;
    }

    // int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    // uint64 timestamp = 4;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for ProposeReplyPayload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ok = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.command_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ok != false {
            my_size += 2;
        }
        if self.command_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.command_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ok != false {
            os.write_bool(1, self.ok)?;
        }
        if self.command_id != 0 {
            os.write_uint32(2, self.command_id)?;
        }
        if self.value != 0 {
            os.write_int32(3, self.value)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposeReplyPayload {
        ProposeReplyPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ok",
                |m: &ProposeReplyPayload| { &m.ok },
                |m: &mut ProposeReplyPayload| { &mut m.ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "command_id",
                |m: &ProposeReplyPayload| { &m.command_id },
                |m: &mut ProposeReplyPayload| { &mut m.command_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &ProposeReplyPayload| { &m.value },
                |m: &mut ProposeReplyPayload| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timestamp",
                |m: &ProposeReplyPayload| { &m.timestamp },
                |m: &mut ProposeReplyPayload| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposeReplyPayload>(
                "ProposeReplyPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposeReplyPayload {
        static instance: ::protobuf::rt::LazyV2<ProposeReplyPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposeReplyPayload::new)
    }
}

impl ::protobuf::Clear for ProposeReplyPayload {
    fn clear(&mut self) {
        self.ok = false;
        self.command_id = 0;
        self.value = 0;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposeReplyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposeReplyPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Instance {
    // message fields
    pub replica: u32,
    pub slot: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Instance {
    fn default() -> &'a Instance {
        <Instance as ::protobuf::Message>::default_instance()
    }
}

impl Instance {
    pub fn new() -> Instance {
        ::std::default::Default::default()
    }

    // uint32 replica = 1;


    pub fn get_replica(&self) -> u32 {
        self.replica
    }
    pub fn clear_replica(&mut self) {
        self.replica = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica(&mut self, v: u32) {
        self.replica = v;
    }

    // uint32 slot = 2;


    pub fn get_slot(&self) -> u32 {
        self.slot
    }
    pub fn clear_slot(&mut self) {
        self.slot = 0;
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = v;
    }
}

impl ::protobuf::Message for Instance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replica = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.replica != 0 {
            my_size += ::protobuf::rt::value_size(1, self.replica, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.slot != 0 {
            my_size += ::protobuf::rt::value_size(2, self.slot, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.replica != 0 {
            os.write_uint32(1, self.replica)?;
        }
        if self.slot != 0 {
            os.write_uint32(2, self.slot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instance {
        Instance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replica",
                |m: &Instance| { &m.replica },
                |m: &mut Instance| { &mut m.replica },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot",
                |m: &Instance| { &m.slot },
                |m: &mut Instance| { &mut m.slot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Instance>(
                "Instance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instance {
        static instance: ::protobuf::rt::LazyV2<Instance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Instance::new)
    }
}

impl ::protobuf::Clear for Instance {
    fn clear(&mut self) {
        self.replica = 0;
        self.slot = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreAcceptPayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ballot: u32,
    pub command: ::protobuf::RepeatedField<Command>,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreAcceptPayload {
    fn default() -> &'a PreAcceptPayload {
        <PreAcceptPayload as ::protobuf::Message>::default_instance()
    }
}

impl PreAcceptPayload {
    pub fn new() -> PreAcceptPayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // repeated .epaxos.Command command = 4;


    pub fn get_command(&self) -> &[Command] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // uint32 seq = 5;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 6;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PreAcceptPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(5, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        for v in &self.command {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint32(5, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreAcceptPayload {
        PreAcceptPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &PreAcceptPayload| { &m.leader_id },
                |m: &mut PreAcceptPayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &PreAcceptPayload| { &m.instance },
                |m: &mut PreAcceptPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &PreAcceptPayload| { &m.ballot },
                |m: &mut PreAcceptPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &PreAcceptPayload| { &m.command },
                |m: &mut PreAcceptPayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &PreAcceptPayload| { &m.seq },
                |m: &mut PreAcceptPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &PreAcceptPayload| { &m.deps },
                |m: &mut PreAcceptPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreAcceptPayload>(
                "PreAcceptPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreAcceptPayload {
        static instance: ::protobuf::rt::LazyV2<PreAcceptPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreAcceptPayload::new)
    }
}

impl ::protobuf::Clear for PreAcceptPayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.ballot = 0;
        self.command.clear();
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreAcceptPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreAcceptPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreAcceptReplyPayload {
    // message fields
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ok: u32,
    pub ballot: u32,
    pub command: ::protobuf::RepeatedField<Command>,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    pub committed_deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreAcceptReplyPayload {
    fn default() -> &'a PreAcceptReplyPayload {
        <PreAcceptReplyPayload as ::protobuf::Message>::default_instance()
    }
}

impl PreAcceptReplyPayload {
    pub fn new() -> PreAcceptReplyPayload {
        ::std::default::Default::default()
    }

    // .epaxos.Instance instance = 1;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ok = 2;


    pub fn get_ok(&self) -> u32 {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: u32) {
        self.ok = v;
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // repeated .epaxos.Command command = 4;


    pub fn get_command(&self) -> &[Command] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // uint32 seq = 5;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 6;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }

    // repeated .epaxos.Instance committed_deps = 7;


    pub fn get_committed_deps(&self) -> &[Instance] {
        &self.committed_deps
    }
    pub fn clear_committed_deps(&mut self) {
        self.committed_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_committed_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.committed_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_committed_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.committed_deps
    }

    // Take field
    pub fn take_committed_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.committed_deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PreAcceptReplyPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.committed_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ok = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.committed_deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(5, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.committed_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != 0 {
            os.write_uint32(2, self.ok)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        for v in &self.command {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint32(5, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.committed_deps {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreAcceptReplyPayload {
        PreAcceptReplyPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &PreAcceptReplyPayload| { &m.instance },
                |m: &mut PreAcceptReplyPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ok",
                |m: &PreAcceptReplyPayload| { &m.ok },
                |m: &mut PreAcceptReplyPayload| { &mut m.ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &PreAcceptReplyPayload| { &m.ballot },
                |m: &mut PreAcceptReplyPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &PreAcceptReplyPayload| { &m.command },
                |m: &mut PreAcceptReplyPayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &PreAcceptReplyPayload| { &m.seq },
                |m: &mut PreAcceptReplyPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &PreAcceptReplyPayload| { &m.deps },
                |m: &mut PreAcceptReplyPayload| { &mut m.deps },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "committed_deps",
                |m: &PreAcceptReplyPayload| { &m.committed_deps },
                |m: &mut PreAcceptReplyPayload| { &mut m.committed_deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreAcceptReplyPayload>(
                "PreAcceptReplyPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreAcceptReplyPayload {
        static instance: ::protobuf::rt::LazyV2<PreAcceptReplyPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreAcceptReplyPayload::new)
    }
}

impl ::protobuf::Clear for PreAcceptReplyPayload {
    fn clear(&mut self) {
        self.instance.clear();
        self.ok = 0;
        self.ballot = 0;
        self.command.clear();
        self.seq = 0;
        self.deps.clear();
        self.committed_deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreAcceptReplyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreAcceptReplyPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreAcceptOKPayload {
    // message fields
    pub instance: ::protobuf::SingularPtrField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreAcceptOKPayload {
    fn default() -> &'a PreAcceptOKPayload {
        <PreAcceptOKPayload as ::protobuf::Message>::default_instance()
    }
}

impl PreAcceptOKPayload {
    pub fn new() -> PreAcceptOKPayload {
        ::std::default::Default::default()
    }

    // .epaxos.Instance instance = 1;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }
}

impl ::protobuf::Message for PreAcceptOKPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreAcceptOKPayload {
        PreAcceptOKPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &PreAcceptOKPayload| { &m.instance },
                |m: &mut PreAcceptOKPayload| { &mut m.instance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreAcceptOKPayload>(
                "PreAcceptOKPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreAcceptOKPayload {
        static instance: ::protobuf::rt::LazyV2<PreAcceptOKPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreAcceptOKPayload::new)
    }
}

impl ::protobuf::Clear for PreAcceptOKPayload {
    fn clear(&mut self) {
        self.instance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreAcceptOKPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreAcceptOKPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptPayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ballot: u32,
    pub count: u32,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptPayload {
    fn default() -> &'a AcceptPayload {
        <AcceptPayload as ::protobuf::Message>::default_instance()
    }
}

impl AcceptPayload {
    pub fn new() -> AcceptPayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // uint32 count = 4;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }

    // uint32 seq = 5;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 6;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AcceptPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(5, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        if self.count != 0 {
            os.write_uint32(4, self.count)?;
        }
        if self.seq != 0 {
            os.write_uint32(5, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptPayload {
        AcceptPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &AcceptPayload| { &m.leader_id },
                |m: &mut AcceptPayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &AcceptPayload| { &m.instance },
                |m: &mut AcceptPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &AcceptPayload| { &m.ballot },
                |m: &mut AcceptPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &AcceptPayload| { &m.count },
                |m: &mut AcceptPayload| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &AcceptPayload| { &m.seq },
                |m: &mut AcceptPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &AcceptPayload| { &m.deps },
                |m: &mut AcceptPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptPayload>(
                "AcceptPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptPayload {
        static instance: ::protobuf::rt::LazyV2<AcceptPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptPayload::new)
    }
}

impl ::protobuf::Clear for AcceptPayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.ballot = 0;
        self.count = 0;
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceptReplyPayload {
    // message fields
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ok: u32,
    pub ballot: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptReplyPayload {
    fn default() -> &'a AcceptReplyPayload {
        <AcceptReplyPayload as ::protobuf::Message>::default_instance()
    }
}

impl AcceptReplyPayload {
    pub fn new() -> AcceptReplyPayload {
        ::std::default::Default::default()
    }

    // .epaxos.Instance instance = 1;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ok = 2;


    pub fn get_ok(&self) -> u32 {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: u32) {
        self.ok = v;
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }
}

impl ::protobuf::Message for AcceptReplyPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ok = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != 0 {
            os.write_uint32(2, self.ok)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptReplyPayload {
        AcceptReplyPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &AcceptReplyPayload| { &m.instance },
                |m: &mut AcceptReplyPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ok",
                |m: &AcceptReplyPayload| { &m.ok },
                |m: &mut AcceptReplyPayload| { &mut m.ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &AcceptReplyPayload| { &m.ballot },
                |m: &mut AcceptReplyPayload| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptReplyPayload>(
                "AcceptReplyPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptReplyPayload {
        static instance: ::protobuf::rt::LazyV2<AcceptReplyPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptReplyPayload::new)
    }
}

impl ::protobuf::Clear for AcceptReplyPayload {
    fn clear(&mut self) {
        self.instance.clear();
        self.ok = 0;
        self.ballot = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptReplyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptReplyPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitPayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub command: ::protobuf::RepeatedField<Command>,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitPayload {
    fn default() -> &'a CommitPayload {
        <CommitPayload as ::protobuf::Message>::default_instance()
    }
}

impl CommitPayload {
    pub fn new() -> CommitPayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // repeated .epaxos.Command command = 3;


    pub fn get_command(&self) -> &[Command] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // uint32 seq = 4;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 5;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommitPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.command {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint32(4, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitPayload {
        CommitPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &CommitPayload| { &m.leader_id },
                |m: &mut CommitPayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &CommitPayload| { &m.instance },
                |m: &mut CommitPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &CommitPayload| { &m.command },
                |m: &mut CommitPayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &CommitPayload| { &m.seq },
                |m: &mut CommitPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &CommitPayload| { &m.deps },
                |m: &mut CommitPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitPayload>(
                "CommitPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitPayload {
        static instance: ::protobuf::rt::LazyV2<CommitPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitPayload::new)
    }
}

impl ::protobuf::Clear for CommitPayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.command.clear();
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitShortPayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub count: u32,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitShortPayload {
    fn default() -> &'a CommitShortPayload {
        <CommitShortPayload as ::protobuf::Message>::default_instance()
    }
}

impl CommitShortPayload {
    pub fn new() -> CommitShortPayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }

    // uint32 seq = 4;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 5;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommitShortPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.count != 0 {
            os.write_uint32(3, self.count)?;
        }
        if self.seq != 0 {
            os.write_uint32(4, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitShortPayload {
        CommitShortPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &CommitShortPayload| { &m.leader_id },
                |m: &mut CommitShortPayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &CommitShortPayload| { &m.instance },
                |m: &mut CommitShortPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CommitShortPayload| { &m.count },
                |m: &mut CommitShortPayload| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &CommitShortPayload| { &m.seq },
                |m: &mut CommitShortPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &CommitShortPayload| { &m.deps },
                |m: &mut CommitShortPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitShortPayload>(
                "CommitShortPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitShortPayload {
        static instance: ::protobuf::rt::LazyV2<CommitShortPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitShortPayload::new)
    }
}

impl ::protobuf::Clear for CommitShortPayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.count = 0;
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitShortPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitShortPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreparePayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ballot: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreparePayload {
    fn default() -> &'a PreparePayload {
        <PreparePayload as ::protobuf::Message>::default_instance()
    }
}

impl PreparePayload {
    pub fn new() -> PreparePayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }
}

impl ::protobuf::Message for PreparePayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreparePayload {
        PreparePayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &PreparePayload| { &m.leader_id },
                |m: &mut PreparePayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &PreparePayload| { &m.instance },
                |m: &mut PreparePayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &PreparePayload| { &m.ballot },
                |m: &mut PreparePayload| { &mut m.ballot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreparePayload>(
                "PreparePayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreparePayload {
        static instance: ::protobuf::rt::LazyV2<PreparePayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreparePayload::new)
    }
}

impl ::protobuf::Clear for PreparePayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.ballot = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreparePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreparePayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrepareReplyPayload {
    // message fields
    pub accept_id: u32,
    pub ok: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ballot: u32,
    pub state: PayloadState,
    pub command: ::protobuf::RepeatedField<Command>,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareReplyPayload {
    fn default() -> &'a PrepareReplyPayload {
        <PrepareReplyPayload as ::protobuf::Message>::default_instance()
    }
}

impl PrepareReplyPayload {
    pub fn new() -> PrepareReplyPayload {
        ::std::default::Default::default()
    }

    // uint32 accept_id = 1;


    pub fn get_accept_id(&self) -> u32 {
        self.accept_id
    }
    pub fn clear_accept_id(&mut self) {
        self.accept_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_id(&mut self, v: u32) {
        self.accept_id = v;
    }

    // uint32 ok = 2;


    pub fn get_ok(&self) -> u32 {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: u32) {
        self.ok = v;
    }

    // .epaxos.Instance instance = 3;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ballot = 4;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // .epaxos.PayloadState state = 5;


    pub fn get_state(&self) -> PayloadState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = PayloadState::PREACCEPTED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PayloadState) {
        self.state = v;
    }

    // repeated .epaxos.Command command = 6;


    pub fn get_command(&self) -> &[Command] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // uint32 seq = 7;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 8;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PrepareReplyPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accept_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ok = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accept_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.accept_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ok != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != PayloadState::PREACCEPTED {
            my_size += ::protobuf::rt::enum_size(5, self.state);
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(7, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.accept_id != 0 {
            os.write_uint32(1, self.accept_id)?;
        }
        if self.ok != 0 {
            os.write_uint32(2, self.ok)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ballot != 0 {
            os.write_uint32(4, self.ballot)?;
        }
        if self.state != PayloadState::PREACCEPTED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        for v in &self.command {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint32(7, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareReplyPayload {
        PrepareReplyPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accept_id",
                |m: &PrepareReplyPayload| { &m.accept_id },
                |m: &mut PrepareReplyPayload| { &mut m.accept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ok",
                |m: &PrepareReplyPayload| { &m.ok },
                |m: &mut PrepareReplyPayload| { &mut m.ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &PrepareReplyPayload| { &m.instance },
                |m: &mut PrepareReplyPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &PrepareReplyPayload| { &m.ballot },
                |m: &mut PrepareReplyPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PayloadState>>(
                "state",
                |m: &PrepareReplyPayload| { &m.state },
                |m: &mut PrepareReplyPayload| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &PrepareReplyPayload| { &m.command },
                |m: &mut PrepareReplyPayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &PrepareReplyPayload| { &m.seq },
                |m: &mut PrepareReplyPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &PrepareReplyPayload| { &m.deps },
                |m: &mut PrepareReplyPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrepareReplyPayload>(
                "PrepareReplyPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrepareReplyPayload {
        static instance: ::protobuf::rt::LazyV2<PrepareReplyPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareReplyPayload::new)
    }
}

impl ::protobuf::Clear for PrepareReplyPayload {
    fn clear(&mut self) {
        self.accept_id = 0;
        self.ok = 0;
        self.instance.clear();
        self.ballot = 0;
        self.state = PayloadState::PREACCEPTED;
        self.command.clear();
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrepareReplyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareReplyPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TryPreAcceptPayload {
    // message fields
    pub leader_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ballot: u32,
    pub command: ::protobuf::RepeatedField<Command>,
    pub seq: u32,
    pub deps: ::protobuf::RepeatedField<Instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryPreAcceptPayload {
    fn default() -> &'a TryPreAcceptPayload {
        <TryPreAcceptPayload as ::protobuf::Message>::default_instance()
    }
}

impl TryPreAcceptPayload {
    pub fn new() -> TryPreAcceptPayload {
        ::std::default::Default::default()
    }

    // uint32 leader_id = 1;


    pub fn get_leader_id(&self) -> u32 {
        self.leader_id
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u32) {
        self.leader_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ballot = 3;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // repeated .epaxos.Command command = 4;


    pub fn get_command(&self) -> &[Command] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<Command>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<Command> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<Command> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // uint32 seq = 5;


    pub fn get_seq(&self) -> u32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u32) {
        self.seq = v;
    }

    // repeated .epaxos.Instance deps = 6;


    pub fn get_deps(&self) -> &[Instance] {
        &self.deps
    }
    pub fn clear_deps(&mut self) {
        self.deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_deps(&mut self, v: ::protobuf::RepeatedField<Instance>) {
        self.deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deps(&mut self) -> &mut ::protobuf::RepeatedField<Instance> {
        &mut self.deps
    }

    // Take field
    pub fn take_deps(&mut self) -> ::protobuf::RepeatedField<Instance> {
        ::std::mem::replace(&mut self.deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TryPreAcceptPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.command {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leader_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.command)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leader_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leader_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.command {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(5, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.leader_id != 0 {
            os.write_uint32(1, self.leader_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ballot != 0 {
            os.write_uint32(3, self.ballot)?;
        }
        for v in &self.command {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.seq != 0 {
            os.write_uint32(5, self.seq)?;
        }
        for v in &self.deps {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryPreAcceptPayload {
        TryPreAcceptPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leader_id",
                |m: &TryPreAcceptPayload| { &m.leader_id },
                |m: &mut TryPreAcceptPayload| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &TryPreAcceptPayload| { &m.instance },
                |m: &mut TryPreAcceptPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &TryPreAcceptPayload| { &m.ballot },
                |m: &mut TryPreAcceptPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Command>>(
                "command",
                |m: &TryPreAcceptPayload| { &m.command },
                |m: &mut TryPreAcceptPayload| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq",
                |m: &TryPreAcceptPayload| { &m.seq },
                |m: &mut TryPreAcceptPayload| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "deps",
                |m: &TryPreAcceptPayload| { &m.deps },
                |m: &mut TryPreAcceptPayload| { &mut m.deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TryPreAcceptPayload>(
                "TryPreAcceptPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TryPreAcceptPayload {
        static instance: ::protobuf::rt::LazyV2<TryPreAcceptPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TryPreAcceptPayload::new)
    }
}

impl ::protobuf::Clear for TryPreAcceptPayload {
    fn clear(&mut self) {
        self.leader_id = 0;
        self.instance.clear();
        self.ballot = 0;
        self.command.clear();
        self.seq = 0;
        self.deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TryPreAcceptPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TryPreAcceptPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TryPreAcceptReplyPayload {
    // message fields
    pub accept_id: u32,
    pub instance: ::protobuf::SingularPtrField<Instance>,
    pub ok: u32,
    pub ballot: u32,
    pub conflict_instance: ::protobuf::SingularPtrField<Instance>,
    pub conflict_state: PayloadState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryPreAcceptReplyPayload {
    fn default() -> &'a TryPreAcceptReplyPayload {
        <TryPreAcceptReplyPayload as ::protobuf::Message>::default_instance()
    }
}

impl TryPreAcceptReplyPayload {
    pub fn new() -> TryPreAcceptReplyPayload {
        ::std::default::Default::default()
    }

    // uint32 accept_id = 1;


    pub fn get_accept_id(&self) -> u32 {
        self.accept_id
    }
    pub fn clear_accept_id(&mut self) {
        self.accept_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_id(&mut self, v: u32) {
        self.accept_id = v;
    }

    // .epaxos.Instance instance = 2;


    pub fn get_instance(&self) -> &Instance {
        self.instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instance(&mut self) {
        self.instance.clear();
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: Instance) {
        self.instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instance(&mut self) -> &mut Instance {
        if self.instance.is_none() {
            self.instance.set_default();
        }
        self.instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_instance(&mut self) -> Instance {
        self.instance.take().unwrap_or_else(|| Instance::new())
    }

    // uint32 ok = 3;


    pub fn get_ok(&self) -> u32 {
        self.ok
    }
    pub fn clear_ok(&mut self) {
        self.ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_ok(&mut self, v: u32) {
        self.ok = v;
    }

    // uint32 ballot = 4;


    pub fn get_ballot(&self) -> u32 {
        self.ballot
    }
    pub fn clear_ballot(&mut self) {
        self.ballot = 0;
    }

    // Param is passed by value, moved
    pub fn set_ballot(&mut self, v: u32) {
        self.ballot = v;
    }

    // .epaxos.Instance conflict_instance = 5;


    pub fn get_conflict_instance(&self) -> &Instance {
        self.conflict_instance.as_ref().unwrap_or_else(|| <Instance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_conflict_instance(&mut self) {
        self.conflict_instance.clear();
    }

    pub fn has_conflict_instance(&self) -> bool {
        self.conflict_instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conflict_instance(&mut self, v: Instance) {
        self.conflict_instance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conflict_instance(&mut self) -> &mut Instance {
        if self.conflict_instance.is_none() {
            self.conflict_instance.set_default();
        }
        self.conflict_instance.as_mut().unwrap()
    }

    // Take field
    pub fn take_conflict_instance(&mut self) -> Instance {
        self.conflict_instance.take().unwrap_or_else(|| Instance::new())
    }

    // .epaxos.PayloadState conflict_state = 6;


    pub fn get_conflict_state(&self) -> PayloadState {
        self.conflict_state
    }
    pub fn clear_conflict_state(&mut self) {
        self.conflict_state = PayloadState::PREACCEPTED;
    }

    // Param is passed by value, moved
    pub fn set_conflict_state(&mut self, v: PayloadState) {
        self.conflict_state = v;
    }
}

impl ::protobuf::Message for TryPreAcceptReplyPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.instance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conflict_instance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accept_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ok = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ballot = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conflict_instance)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.conflict_state, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accept_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.accept_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ok != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ballot != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ballot, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.conflict_instance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.conflict_state != PayloadState::PREACCEPTED {
            my_size += ::protobuf::rt::enum_size(6, self.conflict_state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.accept_id != 0 {
            os.write_uint32(1, self.accept_id)?;
        }
        if let Some(ref v) = self.instance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ok != 0 {
            os.write_uint32(3, self.ok)?;
        }
        if self.ballot != 0 {
            os.write_uint32(4, self.ballot)?;
        }
        if let Some(ref v) = self.conflict_instance.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.conflict_state != PayloadState::PREACCEPTED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.conflict_state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryPreAcceptReplyPayload {
        TryPreAcceptReplyPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accept_id",
                |m: &TryPreAcceptReplyPayload| { &m.accept_id },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.accept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "instance",
                |m: &TryPreAcceptReplyPayload| { &m.instance },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ok",
                |m: &TryPreAcceptReplyPayload| { &m.ok },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ballot",
                |m: &TryPreAcceptReplyPayload| { &m.ballot },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.ballot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instance>>(
                "conflict_instance",
                |m: &TryPreAcceptReplyPayload| { &m.conflict_instance },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.conflict_instance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PayloadState>>(
                "conflict_state",
                |m: &TryPreAcceptReplyPayload| { &m.conflict_state },
                |m: &mut TryPreAcceptReplyPayload| { &mut m.conflict_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TryPreAcceptReplyPayload>(
                "TryPreAcceptReplyPayload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TryPreAcceptReplyPayload {
        static instance: ::protobuf::rt::LazyV2<TryPreAcceptReplyPayload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TryPreAcceptReplyPayload::new)
    }
}

impl ::protobuf::Clear for TryPreAcceptReplyPayload {
    fn clear(&mut self) {
        self.accept_id = 0;
        self.instance.clear();
        self.ok = 0;
        self.ballot = 0;
        self.conflict_instance.clear();
        self.conflict_state = PayloadState::PREACCEPTED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TryPreAcceptReplyPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TryPreAcceptReplyPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Empty>(
                "Empty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Empty {
        static instance: ::protobuf::rt::LazyV2<Empty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Empty::new)
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Operation {
    PUT = 0,
    PUT_BLIND = 1,
    GET = 2,
}

impl ::protobuf::ProtobufEnum for Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Operation> {
        match value {
            0 => ::std::option::Option::Some(Operation::PUT),
            1 => ::std::option::Option::Some(Operation::PUT_BLIND),
            2 => ::std::option::Option::Some(Operation::GET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Operation] = &[
            Operation::PUT,
            Operation::PUT_BLIND,
            Operation::GET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Operation>("Operation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Operation {
}

impl ::std::default::Default for Operation {
    fn default() -> Self {
        Operation::PUT
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PayloadState {
    PREACCEPTED = 0,
    PREACCEPTEDEQ = 1,
    ACCEPTED = 2,
    COMMITTED = 3,
    EXECUTED = 4,
}

impl ::protobuf::ProtobufEnum for PayloadState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PayloadState> {
        match value {
            0 => ::std::option::Option::Some(PayloadState::PREACCEPTED),
            1 => ::std::option::Option::Some(PayloadState::PREACCEPTEDEQ),
            2 => ::std::option::Option::Some(PayloadState::ACCEPTED),
            3 => ::std::option::Option::Some(PayloadState::COMMITTED),
            4 => ::std::option::Option::Some(PayloadState::EXECUTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PayloadState] = &[
            PayloadState::PREACCEPTED,
            PayloadState::PREACCEPTEDEQ,
            PayloadState::ACCEPTED,
            PayloadState::COMMITTED,
            PayloadState::EXECUTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PayloadState>("PayloadState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PayloadState {
}

impl ::std::default::Default for PayloadState {
    fn default() -> Self {
        PayloadState::PREACCEPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for PayloadState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cepaxos.proto\x12\x06epaxos\"T\n\x07Command\x12!\n\x02op\x18\x01\
    \x20\x01(\x0e2\x11.epaxos.OperationR\x02op\x12\x10\n\x03key\x18\x02\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\"x\n\
    \x0eProposePayload\x12\x1d\n\ncommand_id\x18\x01\x20\x01(\rR\tcommandId\
    \x12)\n\x07command\x18\x02\x20\x01(\x0b2\x0f.epaxos.CommandR\x07command\
    \x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x04R\ttimestamp\"x\n\x13ProposeRe\
    plyPayload\x12\x0e\n\x02ok\x18\x01\x20\x01(\x08R\x02ok\x12\x1d\n\ncomman\
    d_id\x18\x02\x20\x01(\rR\tcommandId\x12\x14\n\x05value\x18\x03\x20\x01(\
    \x05R\x05value\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x04R\ttimestamp\"8\
    \n\x08Instance\x12\x18\n\x07replica\x18\x01\x20\x01(\rR\x07replica\x12\
    \x12\n\x04slot\x18\x02\x20\x01(\rR\x04slot\"\xd8\x01\n\x10PreAcceptPaylo\
    ad\x12\x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08leaderId\x12,\n\x08instan\
    ce\x18\x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12\x16\n\x06b\
    allot\x18\x03\x20\x01(\rR\x06ballot\x12)\n\x07command\x18\x04\x20\x03(\
    \x0b2\x0f.epaxos.CommandR\x07command\x12\x10\n\x03seq\x18\x05\x20\x01(\r\
    R\x03seq\x12$\n\x04deps\x18\x06\x20\x03(\x0b2\x10.epaxos.InstanceR\x04de\
    ps\"\x89\x02\n\x15PreAcceptReplyPayload\x12,\n\x08instance\x18\x01\x20\
    \x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12\x0e\n\x02ok\x18\x02\x20\
    \x01(\rR\x02ok\x12\x16\n\x06ballot\x18\x03\x20\x01(\rR\x06ballot\x12)\n\
    \x07command\x18\x04\x20\x03(\x0b2\x0f.epaxos.CommandR\x07command\x12\x10\
    \n\x03seq\x18\x05\x20\x01(\rR\x03seq\x12$\n\x04deps\x18\x06\x20\x03(\x0b\
    2\x10.epaxos.InstanceR\x04deps\x127\n\x0ecommitted_deps\x18\x07\x20\x03(\
    \x0b2\x10.epaxos.InstanceR\rcommittedDeps\"B\n\x12PreAcceptOKPayload\x12\
    ,\n\x08instance\x18\x01\x20\x01(\x0b2\x10.epaxos.InstanceR\x08instance\"\
    \xc0\x01\n\rAcceptPayload\x12\x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08le\
    aderId\x12,\n\x08instance\x18\x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08\
    instance\x12\x16\n\x06ballot\x18\x03\x20\x01(\rR\x06ballot\x12\x14\n\x05\
    count\x18\x04\x20\x01(\rR\x05count\x12\x10\n\x03seq\x18\x05\x20\x01(\rR\
    \x03seq\x12$\n\x04deps\x18\x06\x20\x03(\x0b2\x10.epaxos.InstanceR\x04dep\
    s\"j\n\x12AcceptReplyPayload\x12,\n\x08instance\x18\x01\x20\x01(\x0b2\
    \x10.epaxos.InstanceR\x08instance\x12\x0e\n\x02ok\x18\x02\x20\x01(\rR\
    \x02ok\x12\x16\n\x06ballot\x18\x03\x20\x01(\rR\x06ballot\"\xbd\x01\n\rCo\
    mmitPayload\x12\x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08leaderId\x12,\n\
    \x08instance\x18\x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12)\
    \n\x07command\x18\x03\x20\x03(\x0b2\x0f.epaxos.CommandR\x07command\x12\
    \x10\n\x03seq\x18\x04\x20\x01(\rR\x03seq\x12$\n\x04deps\x18\x05\x20\x03(\
    \x0b2\x10.epaxos.InstanceR\x04deps\"\xad\x01\n\x12CommitShortPayload\x12\
    \x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08leaderId\x12,\n\x08instance\x18\
    \x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12\x14\n\x05count\
    \x18\x03\x20\x01(\rR\x05count\x12\x10\n\x03seq\x18\x04\x20\x01(\rR\x03se\
    q\x12$\n\x04deps\x18\x05\x20\x03(\x0b2\x10.epaxos.InstanceR\x04deps\"s\n\
    \x0ePreparePayload\x12\x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08leaderId\
    \x12,\n\x08instance\x18\x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08instan\
    ce\x12\x16\n\x06ballot\x18\x03\x20\x01(\rR\x06ballot\"\x97\x02\n\x13Prep\
    areReplyPayload\x12\x1b\n\taccept_id\x18\x01\x20\x01(\rR\x08acceptId\x12\
    \x0e\n\x02ok\x18\x02\x20\x01(\rR\x02ok\x12,\n\x08instance\x18\x03\x20\
    \x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12\x16\n\x06ballot\x18\x04\
    \x20\x01(\rR\x06ballot\x12*\n\x05state\x18\x05\x20\x01(\x0e2\x14.epaxos.\
    PayloadStateR\x05state\x12)\n\x07command\x18\x06\x20\x03(\x0b2\x0f.epaxo\
    s.CommandR\x07command\x12\x10\n\x03seq\x18\x07\x20\x01(\rR\x03seq\x12$\n\
    \x04deps\x18\x08\x20\x03(\x0b2\x10.epaxos.InstanceR\x04deps\"\xdb\x01\n\
    \x13TryPreAcceptPayload\x12\x1b\n\tleader_id\x18\x01\x20\x01(\rR\x08lead\
    erId\x12,\n\x08instance\x18\x02\x20\x01(\x0b2\x10.epaxos.InstanceR\x08in\
    stance\x12\x16\n\x06ballot\x18\x03\x20\x01(\rR\x06ballot\x12)\n\x07comma\
    nd\x18\x04\x20\x03(\x0b2\x0f.epaxos.CommandR\x07command\x12\x10\n\x03seq\
    \x18\x05\x20\x01(\rR\x03seq\x12$\n\x04deps\x18\x06\x20\x03(\x0b2\x10.epa\
    xos.InstanceR\x04deps\"\x89\x02\n\x18TryPreAcceptReplyPayload\x12\x1b\n\
    \taccept_id\x18\x01\x20\x01(\rR\x08acceptId\x12,\n\x08instance\x18\x02\
    \x20\x01(\x0b2\x10.epaxos.InstanceR\x08instance\x12\x0e\n\x02ok\x18\x03\
    \x20\x01(\rR\x02ok\x12\x16\n\x06ballot\x18\x04\x20\x01(\rR\x06ballot\x12\
    =\n\x11conflict_instance\x18\x05\x20\x01(\x0b2\x10.epaxos.InstanceR\x10c\
    onflictInstance\x12;\n\x0econflict_state\x18\x06\x20\x01(\x0e2\x14.epaxo\
    s.PayloadStateR\rconflictState\"\x07\n\x05Empty*,\n\tOperation\x12\x07\n\
    \x03PUT\x10\0\x12\r\n\tPUT_BLIND\x10\x01\x12\x07\n\x03GET\x10\x02*]\n\
    \x0cPayloadState\x12\x0f\n\x0bPREACCEPTED\x10\0\x12\x11\n\rPREACCEPTEDEQ\
    \x10\x01\x12\x0c\n\x08ACCEPTED\x10\x02\x12\r\n\tCOMMITTED\x10\x03\x12\
    \x0c\n\x08EXECUTED\x10\x042\xdc\x03\n\rEpaxosService\x12G\n\npre_accept\
    \x12\x18.epaxos.PreAcceptPayload\x1a\x1d.epaxos.PreAcceptReplyPayload\"\
    \0\x12=\n\x06accept\x12\x15.epaxos.AcceptPayload\x1a\x1a.epaxos.AcceptRe\
    plyPayload\"\0\x120\n\x06commit\x12\x15.epaxos.CommitPayload\x1a\r.epaxo\
    s.Empty\"\0\x12:\n\x0bcommitshort\x12\x1a.epaxos.CommitShortPayload\x1a\
    \r.epaxos.Empty\"\0\x12@\n\x07propose\x12\x16.epaxos.ProposePayload\x1a\
    \x1b.epaxos.ProposeReplyPayload\"\0\x12@\n\x07prepare\x12\x16.epaxos.Pre\
    parePayload\x1a\x1b.epaxos.PrepareReplyPayload\"\0\x12Q\n\x0etry_pre_acc\
    ept\x12\x1b.epaxos.TryPreAcceptPayload\x1a\x20.epaxos.TryPreAcceptReplyP\
    ayload\"\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
